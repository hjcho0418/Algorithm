//#include <iostream> //240808 누적 합
//#include <vector>  
//
//using namespace std;
//
//int main() {
//    ios_base::sync_with_stdio(false);
//    cin.tie(nullptr);
//
//    int N, M;
//    cin >> N >> M;
//    vector<int> v(N);
//   
//    for (int i = 0; i < v.size(); i++) {
//        cin >> v[i];
//    }
//    
//    while (M--) {
//        int i, j, sum=0;
//        cin >> i >> j;
//        for (int k = i-1; k < j; k++) {
//            sum += v[k];
//        }
//        cout << sum <<"\n";
//    }
//
//    return 0;
//}

#include <iostream> 
#include <vector>

using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    cin >> N >> M;
    vector<int> v(N);
    vector<int> sum(N + 1, 0);

    for (int i = 0; i < N; i++) {
        cin >> v[i];
        sum[i + 1] = sum[i] + v[i];
    }

    while (M--) {
        int i, j;
        cin >> i >> j;
        cout << sum[j] - sum[i - 1] << "\n";
    }

    return 0;
}
//이 최적화된 코드는 시간 복잡도를 크게 개선하여 입력 크기가 커질수록 성능이 좋아집니다. 각 단계별 시간 복잡도를 구체적으로 살펴보겠습니다.
//
//초기 코드 분석
//초기 코드에서는 각 질의에 대해 반복문을 사용하여 합계를 계산합니다.시간 복잡도는 다음과 같습니다 :
//
//입력 받기 :
//벡터 v의 크기 N과 질의 수 M을 입력 받습니다.이는 O(1)입니다.
//벡터 v의 각 원소를 입력 받습니다.이는 O(N)입니다.
//질의 처리 :
//각 질의마다 구간[i, j]의 합을 계산합니다.이는 반복문을 사용하여 구간의 합을 계산하므로 O(j - i + 1)입니다.
//최악의 경우 이 구간이 전체 벡터를 포함할 수 있으므로, 각 질의는 O(N)입니다.
//M개의 질의를 처리해야 하므로 전체 질의 처리 시간은 O(M* N)입니다.
//따라서 초기 코드의 전체 시간 복잡도는 O(N + M * N)입니다.
//
//최적화된 코드 분석
//최적화된 코드에서는 미리 구간 합을 계산하여 질의를 처리합니다.시간 복잡도는 다음과 같습니다 :
//
//입력 받기 및 부분 합 계산 :
//벡터 v의 크기 N과 질의 수 M을 입력 받습니다.이는 O(1)입니다.
//벡터 v의 각 원소를 입력 받습니다.이는 O(N)입니다.
//부분 합 벡터 sum을 계산합니다.각 원소에 대해 이전 부분 합에 현재 원소를 더하는 방식으로 계산하므로 O(N)입니다.
//질의 처리 :
//각 질의마다 구간[i, j]의 합을 sum을 이용하여 계산합니다.이는 O(1)입니다.
//M개의 질의를 처리해야 하므로 전체 질의 처리 시간은 O(M)입니다.
//따라서 최적화된 코드의 전체 시간 복잡도는 O(N + M)입니다.
//
//비교
//초기 코드 : O(N + M * N)
//
//입력 크기 N이 크고 질의 수 M이 많을수록 시간이 많이 소요됩니다.
//예를 들어, N = 100, 000이고 M = 100, 000일 경우, 최악의 경우 시간 복잡도는 O(100, 000 + 100, 000 * 100, 000) = O(10, 000, 010, 000)입니다.
//최적화된 코드 : O(N + M)
//
//입력 크기와 질의 수가 커져도 효율적으로 처리할 수 있습니다.
//예를 들어, N = 100, 000이고 M = 100, 000일 경우, 시간 복잡도는 O(100, 000 + 100, 000) = O(200, 000)입니다.
//따라서 최적화된 코드는 훨씬 더 효율적이며, 큰 입력 크기와 많은 질의에 대해서도 빠르게 처리할 수 있습니다.
